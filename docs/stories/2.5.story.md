# Story 2.5: Tag Management Interface

## Status

Done

## Story

**As a** user,
**I want** a dedicated interface to view, edit, and organize all my tags,
**so that** I can maintain a clean and useful tagging system.

## Acceptance Criteria

1. Tag overview page displaying all tags with usage statistics
2. Inline tag editing (name, color) with immediate preview
3. Tag deletion with warning about associated task impacts
4. Tag merging functionality to combine similar tags
5. Unused tag identification and bulk cleanup options
6. Tag sorting by name, usage frequency, or creation date
7. Search functionality to find specific tags in large collections

## Tasks / Subtasks

- [x] Task 1: Extend `TagListView` with sort, search, and unused filter (AC: 1, 5, 6, 7)
  - [x] Add `TAG_SORT_OPTIONS` dict to `views.py`: keys `name`, `-name`, `num_tasks`, `-num_tasks`, `created_at`, `-created_at` mapped to ORM order fields
  - [x] Extend `get_queryset()`: read `q` GET param → `name__icontains=q`; read `show_unused` GET param → filter `num_tasks=0`; read `sort` GET param (default `"name"`) → apply sort via `TAG_SORT_OPTIONS`
  - [x] Extend `get_context_data()`: add `current_sort`, `current_q`, `show_unused` (bool), `tag_list_base_params` (current params minus `sort`), `toggle_unused_url` (flips `show_unused` while preserving `q`/`sort`) to context
  - [x] Update `tag_list.html`: add search `<input>` + submit button above table; add sort links on column headers using `tag_list_base_params` (see Dev Notes); add `toggle_unused_url` toggle button; add `created_at` column to table

- [x] Task 2: Add inline tag name editing AJAX endpoint (AC: 2)
  - [x] Create `TagNameUpdateView` in `apps/tasks/views.py`: `LoginRequiredMixin`, `View`, POST-only (`http_method_names = ["post"]`), accepts JSON body `{"name": "..."}`, strips whitespace, validates non-empty, validates uniqueness case-insensitively (`name__iexact`, excluding current tag), calls `tag.save(update_fields=["name"])`, returns `{"name": tag.name}` on success (200) or `{"error": "..."}` on failure (400); uses `get_object_or_404(Tag.objects.filter(user=request.user), pk=pk)` for ownership
  - [x] Add URL `tags/<uuid:pk>/name/` → `tag-name-update` in `apps/tasks/urls.py` (alongside other UUID patterns)
  - [x] Add inline name edit UI in `tag_list.html`: clicking the tag badge in the Tag column switches it to an `<input>` field with the current name; on blur or Enter, POST JSON to `tag-name-update`, update the badge text and close the input; on Escape, cancel; show inline error (e.g., red border + small error text) on failure
  - [x] Include CSRF token via `getCookie('csrftoken')` (globally available from `static/js/base.js`)

- [x] Task 3: Implement tag merging (AC: 4)
  - [x] Create `TagMergeView` in `apps/tasks/views.py`: `LoginRequiredMixin`, `View`, handles GET and POST
    - GET: fetch source tag (`get_object_or_404` filtered by user), fetch all other user tags excluding source, render `tasks/tag_merge.html` with `source_tag` and `other_tags`
    - POST: read `target_tag` from POST data, fetch target (`get_object_or_404` filtered by user), guard against merge-with-self (redirect with error message), iterate `source_tag.tasks.all()` and call `task.tags.add(target_tag)` for each, then `source_tag.delete()`, redirect to `tag-list` with success message
  - [x] Add URL `tags/<uuid:pk>/merge/` → `tag-merge` in `apps/tasks/urls.py` (alongside other UUID patterns)
  - [x] Create `apps/tasks/templates/tasks/tag_merge.html`: extends `base.html`, shows source tag badge, `<select name="target_tag">` populated with `other_tags` (show tag name + task count), submit button "Merge Tag", cancel link back to `tag-list`
  - [x] Add "Merge" link in `tag_list.html` actions column: `<a href="{% url 'tag-merge' pk=tag.pk %}">Merge</a>`

- [x] Task 4: Add unused tag visual identification (AC: 5)
  - [x] In `tag_list.html`, add `class="text-muted"` to each `<tr>` row where `tag.num_tasks == 0`: `<tr{% if tag.num_tasks == 0 %} class="text-muted"{% endif %}>` — this visually dims unused tag rows
  - [x] The "Show unused only" toggle (from Task 1) enables bulk-selecting all visible unused tags for deletion via the existing `TagBulkEditView` bulk-delete action

- [x] Task 5: Write tests (AC: 2, 4, 6, 7)
  - [x] `TestTagListViewSort` in `apps/tasks/tests/test_views.py`:
    - [x] Default sort is by name ascending
    - [x] `?sort=num_tasks` orders tags by task count ascending
    - [x] `?sort=-num_tasks` orders tags by task count descending
    - [x] `?sort=created_at` orders tags by creation date ascending
    - [x] Invalid sort param falls back to name ordering
  - [x] `TestTagListViewSearch` in `apps/tasks/tests/test_views.py`:
    - [x] `?q=foo` returns only tags whose name contains "foo" (case-insensitive)
    - [x] `?q=` (empty) returns all tags
    - [x] Other user's tags are never returned regardless of search
  - [x] `TestTagListViewUnused` in `apps/tasks/tests/test_views.py`:
    - [x] `?show_unused=1` returns only tags with `num_tasks=0`
    - [x] Without param, all tags (including used and unused) returned
  - [x] `TestTagNameUpdateView` in `apps/tasks/tests/test_views.py`:
    - [x] Requires authentication (redirect to login)
    - [x] Returns updated name on valid input (200)
    - [x] Rejects empty or whitespace-only name (400)
    - [x] Rejects duplicate name case-insensitively (400)
    - [x] Allows rename to same name (idempotent, 200)
    - [x] Returns 404 for another user's tag
    - [x] Rejects GET requests (405)
  - [x] `TestTagMergeView` in `apps/tasks/tests/test_views.py`:
    - [x] Requires authentication
    - [x] GET renders form with source tag and other tags
    - [x] POST reassigns all source tag tasks to target tag
    - [x] POST deletes source tag after merge
    - [x] POST with `target_tag == source_tag` (same pk) redirects with error message, does not delete
    - [x] POST rejects merging into another user's tag (404)
    - [x] GET returns 404 for another user's source tag

- [x] Task 6: Validate and verify (AC: 1-7)
  - [x] Run `ruff check .` with no errors
  - [x] Run `ruff format --check .` with no errors
  - [x] Run `pytest` with all tests passing
  - [x] Run `python manage.py check` with no issues
  - [x] Run `python manage.py makemigrations --check` — no new migrations expected

## Dev Notes

### Previous Story Insights

From Story 2.4 (Tag-Based Task Filtering) Dev Agent Record:
- `_build_tag_add_url`, `_build_tag_remove_url`, `_build_clear_tags_url` helpers live at module level in `views.py`
- `TaskListView` pattern for sort/filter via GET params is the established pattern — mirror it in `TagListView`
- `get_item` template filter exists in `apps/tasks/templatetags/task_tags.py`
- `{% load task_tags %}` already at top of `tag_list.html`
- `getCookie('csrftoken')` is globally available from `static/js/base.js` (included in base template)
- 253 tests pass at 99% coverage before this story

From Story 2.3 (Color-Coded Visual Tag System) Dev Agent Record:
- `TagColorUpdateView` POST JSON `{"color": "#hex"}` pattern already in `views.py` — `TagNameUpdateView` follows same pattern
- Inline color picker JS already in `tag_list.html` — inline name editing JS follows same pattern
- `badge_text_color` template filter in `task_tags.py`

### What's Already Implemented — Do NOT Re-implement

- Tag overview page with `num_tasks` (`TagListView` with `annotate(num_tasks=Count("tasks"))`)
- Inline color editing (`TagColorUpdateView` + color picker UI in `tag_list.html`)
- Bulk delete via `TagBulkEditView` (POST `bulk_action=delete` with selected tag PKs)
- Tag deletion with task count warning (`TagDeleteView` + `tag_confirm_delete.html`)
- Export CSV (`TagExportView`)
- Tag CRUD (`TagCreateView`, `TagUpdateView`, `TagDeleteView`)

### Current `TagListView` — Extend This

[Source: `apps/tasks/views.py`]

```python
class TagListView(LoginRequiredMixin, ListView):
    model = Tag
    template_name = "tasks/tag_list.html"
    context_object_name = "tags"

    def get_queryset(self):
        return (
            Tag.objects.filter(user=self.request.user)
            .annotate(num_tasks=Count("tasks"))
            .order_by("name")
        )

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["color_choices"] = Tag.COLOR_CHOICES
        return context
```

**Extend** `get_queryset()` to add sort/search/unused filter. **Extend** `get_context_data()` to pass `current_sort`, `current_q`, `show_unused`. Keep `color_choices` in context.

### Sort Implementation

```python
TAG_SORT_OPTIONS = {
    "name": "name",
    "-name": "-name",
    "num_tasks": "num_tasks",
    "-num_tasks": "-num_tasks",
    "created_at": "created_at",
    "-created_at": "-created_at",
}
```

Place `TAG_SORT_OPTIONS` as a class attribute on `TagListView` (or module-level constant). Apply after annotation so `num_tasks` is available as an order field. Default sort: `"name"`.

**Sort link URL construction** — sort links must preserve the current `q` and `show_unused` params. Add a `tag_list_base_params` context variable in `get_context_data()`:

```python
# In get_context_data():
base_params = self.request.GET.copy()
base_params.pop("sort", None)
context["tag_list_base_params"] = base_params.urlencode()  # e.g. "q=work&show_unused=1"
```

Then in `tag_list.html`, build sort links as:
```django
<a href="?sort=name{% if tag_list_base_params %}&{{ tag_list_base_params }}{% endif %}">Tag Name</a>
<a href="?sort=-num_tasks{% if tag_list_base_params %}&{{ tag_list_base_params }}{% endif %}">Tasks ↓</a>
<a href="?sort=num_tasks{% if tag_list_base_params %}&{{ tag_list_base_params }}{% endif %}">Tasks ↑</a>
<a href="?sort=created_at{% if tag_list_base_params %}&{{ tag_list_base_params }}{% endif %}">Created</a>
```

### Search + Unused Filter Implementation

```python
def get_queryset(self):
    qs = (
        Tag.objects.filter(user=self.request.user)
        .annotate(num_tasks=Count("tasks"))
    )
    q = self.request.GET.get("q", "").strip()
    if q:
        qs = qs.filter(name__icontains=q)
    if self.request.GET.get("show_unused"):
        qs = qs.filter(num_tasks=0)
    sort = self.request.GET.get("sort", "name")
    qs = qs.order_by(self.TAG_SORT_OPTIONS.get(sort, "name"))
    return qs
```

**"Show unused" toggle URL** — add a `toggle_unused_url` context variable in `get_context_data()` that flips `show_unused` on/off while preserving `q` and `sort`:

```python
# In get_context_data():
toggle_unused_params = self.request.GET.copy()
if toggle_unused_params.get("show_unused"):
    toggle_unused_params.pop("show_unused")
else:
    toggle_unused_params["show_unused"] = "1"
toggle_unused_params.pop("page", None)
context["toggle_unused_url"] = "?" + toggle_unused_params.urlencode()
```

In `tag_list.html`:
```django
<a href="{{ toggle_unused_url }}" class="btn btn-sm btn-outline-secondary">
    {% if show_unused %}Show all{% else %}Show unused only{% endif %}
</a>
```

Also add `tag_list_base_params` and `toggle_unused_url` to the `Extend get_context_data()` subtask in Task 1.

### `TagNameUpdateView` Pattern

[Source: Consistent with `TagColorUpdateView` and `TagQuickCreateView` in `apps/tasks/views.py`]

```python
class TagNameUpdateView(LoginRequiredMixin, View):
    http_method_names = ["post"]

    def post(self, request, pk):
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({"error": "Invalid JSON."}, status=400)

        name = data.get("name", "").strip()
        if not name:
            return JsonResponse({"error": "Tag name cannot be empty."}, status=400)
        if len(name) > 50:
            return JsonResponse({"error": "Tag name cannot exceed 50 characters."}, status=400)

        tag = get_object_or_404(Tag.objects.filter(user=request.user), pk=pk)

        # Case-insensitive uniqueness check, excluding current tag
        if Tag.objects.filter(user=request.user, name__iexact=name).exclude(pk=pk).exists():
            return JsonResponse({"error": f"Tag '{name}' already exists."}, status=400)

        tag.name = name
        tag.save(update_fields=["name"])
        return JsonResponse({"name": tag.name})
```

### `TagMergeView` Pattern

```python
class TagMergeView(LoginRequiredMixin, View):
    http_method_names = ["get", "post"]

    def get(self, request, pk):
        source_tag = get_object_or_404(Tag.objects.filter(user=request.user), pk=pk)
        other_tags = (
            Tag.objects.filter(user=request.user)
            .exclude(pk=pk)
            .annotate(num_tasks=Count("tasks"))
            .order_by("name")
        )
        return render(request, "tasks/tag_merge.html", {
            "source_tag": source_tag,
            "other_tags": other_tags,
        })

    def post(self, request, pk):
        source_tag = get_object_or_404(Tag.objects.filter(user=request.user), pk=pk)
        target_pk = request.POST.get("target_tag", "")
        target_tag = get_object_or_404(Tag.objects.filter(user=request.user), pk=target_pk)

        if source_tag.pk == target_tag.pk:
            messages.error(request, "Cannot merge a tag with itself.")
            return redirect("tag-merge", pk=pk)

        # Reassign all tasks from source to target
        for task in source_tag.tasks.all():
            task.tags.add(target_tag)

        source_name = source_tag.name
        source_tag.delete()
        messages.success(request, f'Tag "{source_name}" merged into "{target_tag.name}".')
        return redirect("tag-list")
```

**Note**: `get_object_or_404` with `Tag.objects.filter(user=request.user)` as queryset enforces user ownership for both source and target.

**Note**: `task.tags.add(target_tag)` is safe even if the task already has `target_tag` (ManyToMany `add` is idempotent). No need to check for duplicates.

### Import Addition Required

[Source: `apps/tasks/views.py` — current imports]

`TagMergeView.get()` uses `render()` which is **not currently imported** in `views.py`. Current import is:
```python
from django.shortcuts import get_object_or_404, redirect
```
Add `render` to this import:
```python
from django.shortcuts import get_object_or_404, redirect, render
```

### URL Additions

[Source: `apps/tasks/urls.py` — URL ordering: static paths before UUID patterns]

All new URLs are UUID-based, so they can be appended alongside existing `<uuid:pk>` patterns:

```python
path("tags/<uuid:pk>/name/", TagNameUpdateView.as_view(), name="tag-name-update"),
path("tags/<uuid:pk>/merge/", TagMergeView.as_view(), name="tag-merge"),
```

Add to imports in `urls.py`: `TagNameUpdateView`, `TagMergeView`.

### Inline Name Edit JS Pattern

[Source: Existing inline color picker JS in `tag_list.html` — mirror this pattern]

In the Tag column of `tag_list.html`, wrap the existing badge `<span>` and add a hidden `<input>`:

```html
<td class="position-relative">
    <span class="badge"
          style="background-color: {{ tag.color }}; color: {{ tag.color|badge_text_color }};"
          data-tag-badge="{{ tag.pk }}"
          data-name-editable="{{ tag.pk }}"
          style="cursor: pointer;"
          title="Click to rename">{{ tag.name }}</span>
    <input type="text"
           class="form-control form-control-sm d-none name-edit-input"
           data-tag-pk="{{ tag.pk }}"
           data-name-url="{% url 'tag-name-update' pk=tag.pk %}"
           value="{{ tag.name }}"
           maxlength="50"
           style="display: inline-block; width: 120px;">
    <span class="text-danger small name-error-{{ tag.pk }}" style="display:none;"></span>
</td>
```

JS behavior in `{% block extra_js %}`:
- Click on badge → hide badge, show input (focused and selected)
- On Enter or blur → POST to `tag-name-update`, on success update badge text + value, hide input show badge; on error show inline error
- On Escape → cancel, restore badge

### Tag Model — Fields Available

[Source: `apps/tasks/models.py` / architecture/data-models.md#Tag Model]

```python
class Tag(models.Model):
    COLOR_CHOICES = [...]  # 8 colors
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(...)
    name = models.CharField(max_length=50)
    color = models.CharField(max_length=7, choices=COLOR_CHOICES, default='#4ECDC4')
    created_at = models.DateTimeField(auto_now_add=True)
    # tasks (reverse ManyToMany from Task.tags, related_name='tasks')
```

`Tag.get_task_count()` method exists but prefer `annotate(num_tasks=Count("tasks"))` for queryset efficiency.

### Tag Merge Template

[Source: architecture/source-tree.md — templates at `apps/tasks/templates/tasks/`]

Create `apps/tasks/templates/tasks/tag_merge.html`:

```django
{% extends "base.html" %}
{% load task_tags %}

{% block title %}Merge Tag - Todo App{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-8">
        <h1>Merge Tag</h1>

        <div class="alert alert-warning">
            <p class="mb-0">
                Merge
                <span class="badge" style="background-color: {{ source_tag.color }}; color: {{ source_tag.color|badge_text_color }};">{{ source_tag.name }}</span>
                into another tag. All tasks currently tagged with
                <strong>{{ source_tag.name }}</strong> will be tagged with the target tag instead.
                The <strong>{{ source_tag.name }}</strong> tag will then be deleted.
                <strong>This action cannot be undone.</strong>
            </p>
        </div>

        {% if other_tags %}
        <form method="post">
            {% csrf_token %}
            <div class="mb-3">
                <label for="target_tag" class="form-label">Merge into:</label>
                <select name="target_tag" id="target_tag" class="form-select" required>
                    <option value="">Select a tag...</option>
                    {% for tag in other_tags %}
                    <option value="{{ tag.pk }}">{{ tag.name }} ({{ tag.num_tasks }} task{{ tag.num_tasks|pluralize }})</option>
                    {% endfor %}
                </select>
            </div>
            <div class="d-flex flex-wrap gap-2">
                <button type="submit" class="btn btn-warning touch-target">Merge Tag</button>
                <a href="{% url 'tag-list' %}" class="btn btn-outline-secondary touch-target">Cancel</a>
            </div>
        </form>
        {% else %}
        <div class="alert alert-info">
            <p class="mb-0">No other tags available to merge into. Create another tag first.</p>
        </div>
        <a href="{% url 'tag-list' %}" class="btn btn-outline-secondary">Back to Tags</a>
        {% endif %}
    </div>
</div>
{% endblock %}
```

### File Locations

[Source: architecture/source-tree.md#Application Structure]

Files to create:
- `apps/tasks/templates/tasks/tag_merge.html` — merge confirmation form

Files to modify:
- `apps/tasks/views.py` — extend `TagListView`, add `TagNameUpdateView`, `TagMergeView`, add `TAG_SORT_OPTIONS`
- `apps/tasks/urls.py` — add `tag-name-update`, `tag-merge` URL patterns; import new views
- `apps/tasks/templates/tasks/tag_list.html` — add search form, sort links, unused filter, `created_at` column, inline name edit UI, Merge action link
- `apps/tasks/tests/test_views.py` — add `TestTagListViewSort`, `TestTagListViewSearch`, `TestTagListViewUnused`, `TestTagNameUpdateView`, `TestTagMergeView`

Files to NOT modify: models, migrations, `task_tags.py`, other templates.

### Testing

[Source: architecture/testing-strategy.md#View Tests]

**Test file**: `apps/tasks/tests/test_views.py` — append new test classes

**Standards**:
- `@pytest.mark.django_db` on all classes
- Use `TagFactory`, `TaskFactory`, `UserFactory` from `apps/tasks/tests/factories.py`
- `client.force_login(user)` for auth
- Use `reverse("tag-name-update", kwargs={"pk": tag.pk})` for URLs

**Key test patterns**:

```python
@pytest.mark.django_db
class TestTagNameUpdateView:
    def test_requires_auth(self, client):
        tag = TagFactory()
        url = reverse("tag-name-update", kwargs={"pk": tag.pk})
        response = client.post(url, data='{"name":"x"}', content_type="application/json")
        assert response.status_code == 302

    def test_rename_success(self, client):
        user = UserFactory()
        tag = TagFactory(user=user, name="Old")
        client.force_login(user)
        url = reverse("tag-name-update", kwargs={"pk": tag.pk})
        response = client.post(url, data='{"name":"New"}', content_type="application/json")
        assert response.status_code == 200
        assert response.json()["name"] == "New"
        tag.refresh_from_db()
        assert tag.name == "New"

    def test_rejects_duplicate_name_case_insensitive(self, client):
        user = UserFactory()
        TagFactory(user=user, name="Work")
        tag = TagFactory(user=user, name="Personal")
        client.force_login(user)
        url = reverse("tag-name-update", kwargs={"pk": tag.pk})
        response = client.post(url, data='{"name":"work"}', content_type="application/json")
        assert response.status_code == 400

    def test_rejects_other_users_tag(self, client):
        user = UserFactory()
        other_tag = TagFactory()  # different user
        client.force_login(user)
        url = reverse("tag-name-update", kwargs={"pk": other_tag.pk})
        response = client.post(url, data='{"name":"x"}', content_type="application/json")
        assert response.status_code == 404

@pytest.mark.django_db
class TestTagMergeView:
    def test_get_shows_form(self, client):
        user = UserFactory()
        tag1 = TagFactory(user=user)
        tag2 = TagFactory(user=user)
        client.force_login(user)
        url = reverse("tag-merge", kwargs={"pk": tag1.pk})
        response = client.get(url)
        assert response.status_code == 200
        assert tag2 in response.context["other_tags"]

    def test_post_merges_tasks_and_deletes_source(self, client):
        user = UserFactory()
        source = TagFactory(user=user)
        target = TagFactory(user=user)
        task = TaskFactory(user=user)
        task.tags.add(source)
        client.force_login(user)
        url = reverse("tag-merge", kwargs={"pk": source.pk})
        response = client.post(url, {"target_tag": str(target.pk)})
        assert response.status_code == 302
        assert not Tag.objects.filter(pk=source.pk).exists()
        task.refresh_from_db()
        assert target in task.tags.all()

    def test_merge_with_self_redirects_with_error(self, client):
        user = UserFactory()
        tag = TagFactory(user=user)
        client.force_login(user)
        url = reverse("tag-merge", kwargs={"pk": tag.pk})
        response = client.post(url, {"target_tag": str(tag.pk)})
        assert response.status_code == 302
        assert Tag.objects.filter(pk=tag.pk).exists()  # Not deleted
```

**Run tests**: `.venv/bin/pytest`
**Run linting**: `.venv/bin/ruff check . && .venv/bin/ruff format --check .`

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-6

### Completion Notes

- `TAG_SORT_OPTIONS` placed at module level (alongside existing `SORT_OPTIONS`) in `views.py`
- `render` added to `django.shortcuts` import (was missing — used by `TagMergeView`)
- Inline name edit JS mirrors existing inline color picker pattern exactly; blur handler only POSTs if value changed (avoids spurious network calls)
- 276 tests pass at 99% coverage; `views.py` at 98% (8 missed lines are defensive error branches)
- No new dependencies, no migrations

### Debug Log References

None

### File List

- `apps/tasks/views.py` — extended `TagListView`; added `TAG_SORT_OPTIONS`, `TagNameUpdateView`, `TagMergeView`; added `render` import
- `apps/tasks/urls.py` — added `tag-name-update`, `tag-merge` URL patterns; imported `TagNameUpdateView`, `TagMergeView`
- `apps/tasks/templates/tasks/tag_list.html` — added search form, sort links, unused toggle, `created_at` column, inline name edit UI, Merge action link, unused row dimming
- `apps/tasks/templates/tasks/tag_merge.html` — new template for merge confirmation form
- `apps/tasks/tests/test_views.py` — added `TestTagListViewSort`, `TestTagListViewSearch`, `TestTagListViewUnused`, `TestTagNameUpdateView`, `TestTagMergeView`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-18 | 0.1 | Initial story draft | SM Agent (Bob) |
| 2026-02-19 | 0.2 | PO review: added sort URL pattern, show_unused toggle URL, clarified unused visual indicator | PO Agent (Sarah) |
| 2026-02-19 | 0.3 | Implementation complete | Dev Agent (James) |
