# Story 2.4: Tag-Based Task Filtering

## Status

Done

## Story

**As a** user,
**I want** to click on tags to filter my task list and see related items,
**so that** I can focus on specific categories of work.

## Acceptance Criteria

1. Clickable tags in task lists that apply instant filtering
2. Multiple tag selection for AND/OR filtering combinations
3. Clear visual indication of active filters with breadcrumb navigation
4. Filter state preserved in URL for bookmarking and sharing
5. Easy filter removal with clear "x" buttons or escape mechanisms
6. Filtered views show task count and maintain sorting preferences
7. Filter combinations display clearly (e.g., "Tasks tagged: urgent AND project")

## Tasks / Subtasks

- [x] Task 1: Extend `TaskListView` to filter by tag(s) (AC: 1, 2, 4, 6)
  - [x] Read `tags` GET param via `request.GET.getlist("tags")` — list of UUID strings
  - [x] Read `tag_mode` GET param (`"and"` default or `"or"`) for AND/OR logic
  - [x] Apply AND filter: `qs.filter(tags__pk__in=tag_ids)` iterated via `.filter()` chain or `Q` objects (one `.filter(tags=pk)` call per selected tag to enforce AND); apply OR via single `.filter(tags__pk__in=tag_ids).distinct()`
  - [x] Existing `status` and `sort` filters continue to work alongside tag filter
  - [x] No new migrations needed

- [x] Task 2: Add tag filter context to `TaskListView.get_context_data()` (AC: 3, 5, 6, 7)
  - [x] Add helpers `_build_tag_add_url(request, tag_pk)` and `_build_tag_remove_url(request, tag_pk)` in `views.py` — use `request.GET.copy()`, modify `tags` list, remove `page` param, return `"?" + params.urlencode()`
  - [x] Pass `active_tag_ids` (list of UUID strings), `active_tags` (Tag queryset for those ids, user-scoped)
  - [x] Pass `tag_add_urls` dict (str(tag.pk) → add URL) and `tag_remove_urls` dict (str(tag.pk) → remove URL) for ALL user tags
  - [x] Pass `clear_tags_url` — current URL with `tags` and `tag_mode` params stripped, `page` stripped
  - [x] Pass `tag_mode` (string: `"and"` or `"or"`)
  - [x] Pass `task_total` — `self.get_queryset().count()` for filtered count display
  - [x] Pass `user_tags` — all of user's tags (for potential filter UI)

- [x] Task 3: Add `get_item` template filter to `apps/tasks/templatetags/task_tags.py` (AC: 1)
  - [x] Add `@register.filter def get_item(dictionary, key): return dictionary.get(str(key))`
  - [x] This allows `{{ tag_add_urls|get_item:tag.pk }}` in templates

- [x] Task 4: Update `task_list.html` — filter bar and clickable badges (AC: 1, 3, 5, 6, 7)
  - [x] Tag badges in each task row become `<a>` links using `{{ tag_add_urls|get_item:tag.pk }}` — toggle behavior (add if not active; clicking active tag removes it via `tag_remove_urls`)
  - [x] Add filter status bar above task list (shown when `active_tags` is non-empty):
    - Display "Tasks tagged: [Tag1] AND [Tag2]" (or "OR") with badge styling
    - Each active tag has an "×" link using `{{ tag_remove_urls|get_item:tag.pk }}`
    - "Clear all filters" link using `{{ clear_tags_url }}`
    - AND/OR toggle button: switches between `tag_mode=and` and `tag_mode=or` while preserving other params
  - [x] Show task count in header: "My Tasks ({{ task_total }})" when filter is active; plain "My Tasks" when no filter
  - [x] Tag badges in task rows: if tag is in `active_tag_ids`, style as active (e.g., add `border border-dark` or `fw-bold`); otherwise normal
  - [x] Preserve `status`, `sort` params when building filter URLs (handled by helper functions in Task 2)

- [x] Task 5: Write tests (AC: 1, 2, 4, 5, 6)
  - [x] `TestTaskListViewTagFilter` class in `apps/tasks/tests/test_views.py`:
    - [x] Single tag filter: only tasks with that tag appear
    - [x] AND mode: only tasks with ALL selected tags appear
    - [x] OR mode: tasks with ANY of the selected tags appear
    - [x] Tag filter combined with status filter
    - [x] Tag filter combined with sort param
    - [x] Invalid/other-user tag UUID in filter → ignored (no 500)
    - [x] Active tags context: correct tags present when filtering
    - [x] task_total context: correct count when filtering
    - [x] tag_mode defaults to "and"
  - [x] `TestGetItemFilter` in `apps/tasks/tests/test_template_tags.py`:
    - [x] dict lookup returns correct value by string key
    - [x] dict lookup returns None for missing key
    - [x] int key is coerced to string

- [x] Task 6: Validate and verify (AC: 1-7)
  - [x] Run `ruff check .` with no errors
  - [x] Run `ruff format --check .` with no errors
  - [x] Run `pytest` with all tests passing
  - [x] Run `python manage.py check` with no issues
  - [x] Run `python manage.py makemigrations --check` — no new migrations expected

## Dev Notes

### Previous Story Insights

From Story 2.3 (Color-Coded Visual Tag System) Dev Agent Record:
- `badge_text_color` template filter exists in `apps/tasks/templatetags/task_tags.py` — add `get_item` filter to the same file
- `{% load task_tags %}` already in `task_list.html` — no need to re-add
- Template pattern for tag badges: `<span class="badge" style="background-color: {{ tag.color }}; color: {{ tag.color|badge_text_color }};">{{ tag.name }}</span>`
- URL ordering pattern: static paths before UUID patterns in `urls.py`
- All 238 tests pass at 99% coverage before this story

### Existing `TaskListView` Pattern

[Source: `apps/tasks/views.py`]

Current view already handles `status` and `sort` GET params:

```python
class TaskListView(LoginRequiredMixin, ListView):
    model = Task
    template_name = "tasks/task_list.html"
    context_object_name = "tasks"
    paginate_by = 25

    def get_queryset(self):
        qs = Task.objects.filter(user=self.request.user).prefetch_related("tags")
        status = self.request.GET.get("status")
        if status == "active":
            qs = qs.filter(status__in=["todo", "in_progress"])
        elif status in ("todo", "in_progress", "done"):
            qs = qs.filter(status=status)
        sort = self.request.GET.get("sort")
        if sort in SORT_OPTIONS:
            qs = qs.order_by(SORT_OPTIONS[sort])
        else:
            qs = qs.order_by(PRIORITY_ORDER, "-created_at")
        return qs

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["current_status"] = self.request.GET.get("status", "")
        context["current_sort"] = self.request.GET.get("sort", "")
        return context
```

**Extend** `get_queryset()` by appending tag filtering **after** existing status/sort logic. **Extend** `get_context_data()` by adding the new context keys listed in Task 2.

### Tag Filter Query Logic

[Source: architecture/data-models.md#Task-Tag Relationship]

**AND filtering** (tasks must have ALL selected tags):
```python
# Each .filter() call narrows the queryset — chaining enforces AND
for tag_id in tag_ids:
    qs = qs.filter(tags__pk=tag_id)
```

**OR filtering** (tasks with ANY selected tag):
```python
from django.db.models import Q
qs = qs.filter(tags__pk__in=tag_ids).distinct()
```

**Important**: For AND filtering, do NOT use `.filter(tags__pk__in=tag_ids)` — that is OR logic! Use the chained `.filter()` approach.

### URL Building Helpers

Add these module-level helpers in `views.py`:

```python
def _build_tag_add_url(request, tag_pk):
    """Return URL with tag_pk added to the 'tags' filter param."""
    params = request.GET.copy()
    existing = params.getlist("tags")
    if str(tag_pk) not in existing:
        existing.append(str(tag_pk))
    params.setlist("tags", existing)
    params.pop("page", None)
    return "?" + params.urlencode()


def _build_tag_remove_url(request, tag_pk):
    """Return URL with tag_pk removed from the 'tags' filter param."""
    params = request.GET.copy()
    existing = [t for t in params.getlist("tags") if t != str(tag_pk)]
    params.setlist("tags", existing)
    params.pop("page", None)
    return "?" + params.urlencode()


def _build_clear_tags_url(request):
    """Return URL with all tag filter params removed."""
    params = request.GET.copy()
    params.pop("tags", None)
    params.pop("tag_mode", None)
    params.pop("page", None)
    return "?" + params.urlencode() if params else "?"
```

### `get_item` Template Filter

Add to `apps/tasks/templatetags/task_tags.py` alongside `badge_text_color`:

```python
@register.filter
def get_item(dictionary, key):
    """Retrieve a value from a dict by key (coerces key to string)."""
    return dictionary.get(str(key))
```

Usage in template:
```django
{% load task_tags %}
<a href="{{ tag_add_urls|get_item:tag.pk }}">...</a>
```

### Context Data Shape

```python
# In get_context_data:
tag_ids = self.request.GET.getlist("tags")
tag_mode = self.request.GET.get("tag_mode", "and")

active_tags = Tag.objects.filter(
    user=self.request.user, pk__in=tag_ids
) if tag_ids else Tag.objects.none()

all_user_tags = Tag.objects.filter(user=self.request.user)

tag_add_urls = {
    str(tag.pk): _build_tag_add_url(self.request, tag.pk)
    for tag in all_user_tags
}
tag_remove_urls = {
    str(tag.pk): _build_tag_remove_url(self.request, tag.pk)
    for tag in all_user_tags
}

context.update({
    "active_tag_ids": tag_ids,
    "active_tags": active_tags,
    "tag_mode": tag_mode,
    "tag_add_urls": tag_add_urls,
    "tag_remove_urls": tag_remove_urls,
    "clear_tags_url": _build_clear_tags_url(self.request),
    "task_total": self.get_queryset().count(),
})
```

**Note**: Calling `self.get_queryset().count()` runs an extra query but is acceptable for MVP. Do not call `self.get_queryset()` multiple times — Django caches querysets via the paginator, but `count()` is a separate DB call.

### AND/OR Toggle URL

In the template, the AND/OR toggle switches `tag_mode` while preserving all other params:

```django
{# Toggle tag_mode between 'and' and 'or' #}
{% if tag_mode == 'and' %}
    {% url 'task-list' as base_url %}
    {# Pass tag_mode=or toggle URL via context — or compute in template #}
{% endif %}
```

Simplest approach: compute `toggle_tag_mode_url` in `get_context_data()`:

```python
toggle_params = request.GET.copy()
toggle_params["tag_mode"] = "or" if tag_mode == "and" else "and"
toggle_params.pop("page", None)
context["toggle_tag_mode_url"] = "?" + toggle_params.urlencode()
```

### Template Changes — `task_list.html`

[Source: `apps/tasks/templates/tasks/task_list.html`]

`{% load task_tags %}` already present. Changes needed:

1. **Header** — show task count when filtering:
```django
<h1>My Tasks{% if active_tags %} ({{ task_total }}){% endif %}</h1>
```

2. **Filter bar** — insert above existing status filter row, shown only when `active_tags`:
```django
{% if active_tags %}
<div class="alert alert-info d-flex flex-wrap align-items-center gap-2 py-2 mb-2">
    <span class="fw-semibold me-1">
        {% if tag_mode == 'and' %}AND{% else %}OR{% endif %} filter:
    </span>
    {% for tag in active_tags %}
        <span class="badge d-inline-flex align-items-center gap-1"
              style="background-color: {{ tag.color }}; color: {{ tag.color|badge_text_color }};">
            {{ tag.name }}
            <a href="{{ tag_remove_urls|get_item:tag.pk }}"
               class="text-decoration-none ms-1"
               style="color: inherit;" aria-label="Remove {{ tag.name }} filter">&times;</a>
        </span>
    {% endfor %}
    <a href="{{ toggle_tag_mode_url }}" class="btn btn-sm btn-outline-secondary py-0">
        Switch to {% if tag_mode == 'and' %}OR{% else %}AND{% endif %}
    </a>
    <a href="{{ clear_tags_url }}" class="btn btn-sm btn-outline-secondary py-0">Clear all</a>
</div>
{% endif %}
```

3. **Tag badges in task rows** — make clickable; highlight if active:
```django
{% for tag in task.tags.all %}
    <a href="{% if tag.pk|stringformat:'s' in active_tag_ids %}{{ tag_remove_urls|get_item:tag.pk }}{% else %}{{ tag_add_urls|get_item:tag.pk }}{% endif %}"
       class="badge text-decoration-none {% if tag.pk|stringformat:'s' in active_tag_ids %}border border-dark border-2{% endif %}"
       style="background-color: {{ tag.color }}; color: {{ tag.color|badge_text_color }};">
        {{ tag.name }}
    </a>
{% endfor %}
```

### Data Model Reminder

[Source: architecture/data-models.md#Task Model]

- `Task.tags` — ManyToManyField to `Tag`, related_name `tasks`
- `Tag.pk` — UUID (use `str(tag.pk)` for comparisons in Python, `tag.pk|stringformat:"s"` in templates)
- Query: `Task.objects.filter(user=request.user, tags__pk=uuid_str)` — valid ORM lookup
- `prefetch_related("tags")` already used in `get_queryset()` — keep it

### File Locations

[Source: architecture/source-tree.md#Application Structure]

Files to modify:
- `apps/tasks/views.py` — extend `TaskListView`, add URL helpers
- `apps/tasks/templates/tasks/task_list.html` — filter bar, clickable badges
- `apps/tasks/templatetags/task_tags.py` — add `get_item` filter

Files to create: None.

Files to NOT modify: `urls.py` (no new URL patterns needed — filtering is GET params on existing `task-list` URL), models, migrations.

### Testing

[Source: architecture/testing-strategy.md#View Tests]

**Test file**: `apps/tasks/tests/test_views.py` — add `TestTaskListViewTagFilter` class

**Test standards**:
- `@pytest.mark.django_db`
- Use `TagFactory`, `TaskFactory`, `UserFactory`
- `Client().force_login(user)` pattern
- Test isolation: create user, create tags, assign to tasks, verify only correct tasks appear

**Template filter tests**: `apps/tasks/tests/test_template_tags.py` — add `TestGetItemFilter` class (no `@pytest.mark.django_db` needed — pure Python function)

**Run tests**: `.venv/bin/pytest`
**Run linting**: `.venv/bin/ruff check . && .venv/bin/ruff format --check .`

**Key test patterns**:
```python
# AND filter: only tasks with ALL tags
tag1 = TagFactory(user=user)
tag2 = TagFactory(user=user)
task_both = TaskFactory(user=user, tags=[tag1, tag2])
task_one = TaskFactory(user=user, tags=[tag1])
task_none = TaskFactory(user=user)

response = client.get(
    reverse("task-list") + f"?tags={tag1.pk}&tags={tag2.pk}&tag_mode=and"
)
tasks = list(response.context["tasks"])
assert task_both in tasks
assert task_one not in tasks  # Missing tag2
assert task_none not in tasks
```

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-6

### Completion Notes

- Added `_build_tag_add_url`, `_build_tag_remove_url`, `_build_clear_tags_url` module-level helpers in `views.py`
- `TaskListView.get_queryset()` extended: tag filtering applied after status/sort; AND uses chained `.filter(tags__pk=id)` calls; OR uses `.filter(tags__pk__in=ids).distinct()`
- `TaskListView.get_context_data()` extended: provides `active_tag_ids`, `active_tags`, `tag_mode`, `tag_add_urls`, `tag_remove_urls`, `clear_tags_url`, `toggle_tag_mode_url`, `task_total`, `user_tags`, `page_base_params`
- `page_base_params` added to context (beyond original story tasks) to fix pagination URL preservation for tag params
- `get_item` template filter added to `task_tags.py`
- `task_list.html`: header shows count when filtering; filter bar with AND/OR label, badge ×-remove links, toggle button, clear-all; tag badges in rows are `<a>` links with active-state border; pagination updated to use `page_base_params`
- 253 tests pass at 99% coverage; no new migrations

### Debug Log References

None

### File List

- `apps/tasks/views.py` — extended `TaskListView`, added URL helper functions
- `apps/tasks/templatetags/task_tags.py` — added `get_item` filter
- `apps/tasks/templates/tasks/task_list.html` — filter bar, clickable tag badges, updated pagination
- `apps/tasks/tests/test_views.py` — added `TestTaskListViewTagFilter` (11 tests)
- `apps/tasks/tests/test_template_tags.py` — added `TestGetItemFilter` (4 tests)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-18 | 0.1 | Initial story draft | SM Agent (Bob) |
| 2026-02-18 | 1.0 | Implementation complete | Dev Agent (James) |
