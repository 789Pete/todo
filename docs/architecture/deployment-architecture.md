# Deployment Architecture

## Deployment Overview

The Django To-Do Application is deployed on **PythonAnywhere**, a Platform-as-a-Service (PaaS) optimized for Django applications. The deployment uses GitHub Actions for CI/CD automation.

```mermaid
graph TB
    Dev[Developer] -->|git push| GitHub[GitHub Repository]
    GitHub -->|webhook| Actions[GitHub Actions CI/CD]

    Actions -->|1. Run Tests| Test[pytest + ruff]
    Test -->|Pass| Build[2. Collect Static Files]
    Build -->|Success| Deploy[3. Deploy to PythonAnywhere]

    Deploy -->|API Call| PA[PythonAnywhere]

    subgraph "PythonAnywhere Production"
        PA --> Web[Web Worker<br/>Gunicorn + Django]
        Web --> DB[(PostgreSQL)]
        Web --> Static[Static Files<br/>WhiteNoise]
        Web --> Sentry[Sentry<br/>Error Tracking]
    end

    User[End Users] -->|HTTPS| Web

    style Test fill:#e1f5fd
    style Deploy fill:#c8e6c9
    style Sentry fill:#ffccbc
```

## PythonAnywhere Configuration

### Account Setup

**Account Type**: Hacker Plan ($5/month) or Web Developer Plan (recommended for production)

**Features Needed**:
- âœ… PostgreSQL database
- âœ… HTTPS with Let's Encrypt
- âœ… Custom domain support
- âœ… SSH access
- âœ… Scheduled tasks
- âœ… Always-on web app

### Web App Configuration

**WSGI Configuration** (`/var/www/yourusername_pythonanywhere_com_wsgi.py`):

```python
import os
import sys

# Add project directory to path
path = '/home/yourusername/django-todo-app'
if path not in sys.path:
    sys.path.insert(0, path)

# Set Django settings module
os.environ['DJANGO_SETTINGS_MODULE'] = 'todo_project.settings.production'

# Load environment variables from .env
from dotenv import load_dotenv
load_dotenv(os.path.join(path, '.env'))

# Import Django application
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
```

**Static Files Mapping**:
- URL: `/static/`
- Directory: `/home/yourusername/django-todo-app/staticfiles/`

**Media Files Mapping** (future):
- URL: `/media/`
- Directory: `/home/yourusername/django-todo-app/media/`

### Database Configuration

**PostgreSQL Setup**:

```bash
# Create database on PythonAnywhere
# (via PythonAnywhere Databases tab)
Database name: yourusername$todo_db
Password: (generated by PythonAnywhere)
```

**Connection String** (`.env`):
```bash
DATABASE_URL=postgresql://yourusername:password@yourusername.postgres.pythonanywhere-services.com:10321/yourusername$todo_db
```

### Environment Variables

**Production `.env` file**:

```bash
# Django Configuration
SECRET_KEY=<generated-secret-key>
DEBUG=False
ALLOWED_HOSTS=yourusername.pythonanywhere.com,www.yoursite.com
DJANGO_SETTINGS_MODULE=todo_project.settings.production

# Database
DATABASE_URL=postgresql://yourusername:password@yourusername.postgres.pythonanywhere-services.com:10321/yourusername$todo_db

# Email (for password reset)
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=your-email@gmail.com
EMAIL_HOST_PASSWORD=your-app-specific-password

# Sentry
SENTRY_DSN=https://xxx@sentry.io/xxx

# Security
SECURE_SSL_REDIRECT=True
SECURE_HSTS_SECONDS=31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS=True
SECURE_HSTS_PRELOAD=True
SESSION_COOKIE_SECURE=True
CSRF_COOKIE_SECURE=True
```

---

## CI/CD Pipeline (GitHub Actions)

### Workflow Overview

**Triggers**:
- Push to `main` branch â†’ Full CI/CD (test + deploy)
- Pull request â†’ CI only (test, no deploy)

### CI Workflow (`.github/workflows/ci.yml`)

```yaml
name: CI - Test and Lint

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install uv
        run: curl -LsSf https://astral.sh/uv/install.sh | sh

      - name: Install dependencies
        run: |
          source $HOME/.cargo/env
          uv pip sync requirements/development.txt

      - name: Run ruff linting
        run: |
          source $HOME/.cargo/env
          ruff check .

      - name: Run ruff formatting check
        run: |
          source $HOME/.cargo/env
          ruff format --check .

      - name: Run Django checks
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: python manage.py check

      - name: Run migrations
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: python manage.py migrate

      - name: Run tests with coverage
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: |
          source $HOME/.cargo/env
          pytest --cov=apps --cov-report=xml --cov-report=term

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: false
```

### CD Workflow (`.github/workflows/deploy.yml`)

```yaml
name: CD - Deploy to PythonAnywhere

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    needs: test  # Only deploy if tests pass

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to PythonAnywhere
        env:
          PYTHONANYWHERE_USERNAME: ${{ secrets.PYTHONANYWHERE_USERNAME }}
          PYTHONANYWHERE_API_TOKEN: ${{ secrets.PYTHONANYWHERE_API_TOKEN }}
        run: |
          # Install PythonAnywhere helper
          pip install pythonanywhere

          # Pull latest code
          ssh $PYTHONANYWHERE_USERNAME@ssh.pythonanywhere.com << 'EOF'
            cd ~/django-todo-app
            git pull origin main
            source .venv/bin/activate
            uv pip sync requirements/production.txt
            python manage.py migrate --noinput
            python manage.py collectstatic --noinput
          EOF

          # Reload web app
          curl -X POST \
            -H "Authorization: Token $PYTHONANYWHERE_API_TOKEN" \
            https://www.pythonanywhere.com/api/v0/user/$PYTHONANYWHERE_USERNAME/webapps/$PYTHONANYWHERE_USERNAME.pythonanywhere.com/reload/

      - name: Verify deployment
        run: |
          sleep 10
          curl -f https://${{ secrets.PYTHONANYWHERE_USERNAME }}.pythonanywhere.com/ || exit 1

      - name: Notify Sentry of deployment
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: your-org
          SENTRY_PROJECT: django-todo-app
        run: |
          curl -sL https://sentry.io/get-cli/ | bash
          sentry-cli releases new -p $SENTRY_PROJECT $(git rev-parse --short HEAD)
          sentry-cli releases set-commits $(git rev-parse --short HEAD) --auto
          sentry-cli releases finalize $(git rev-parse --short HEAD)
```

### Secrets Configuration

**GitHub Repository Secrets** (Settings â†’ Secrets and variables â†’ Actions):

| Secret | Value | Purpose |
|--------|-------|---------|
| `PYTHONANYWHERE_USERNAME` | your-username | PythonAnywhere account |
| `PYTHONANYWHERE_API_TOKEN` | xxx | API access token |
| `SENTRY_AUTH_TOKEN` | xxx | Sentry deployment tracking |
| `SECRET_KEY` | xxx | Django secret key (production) |

---

## Deployment Script (Manual Fallback)

**`scripts/deploy.sh`**:

```bash
#!/bin/bash
set -e

echo "ðŸš€ Deploying Django To-Do App to PythonAnywhere"
echo "================================================"

# Configuration
PA_USER="${PYTHONANYWHERE_USERNAME}"
PA_HOST="ssh.pythonanywhere.com"
PROJECT_DIR="django-todo-app"

# Step 1: Pull latest code
echo "ðŸ“¥ Step 1/6: Pulling latest code from GitHub..."
ssh ${PA_USER}@${PA_HOST} << EOF
    cd ~/${PROJECT_DIR}
    git pull origin main
EOF
echo "   âœ… Code updated"

# Step 2: Install dependencies
echo "âš¡ Step 2/6: Installing dependencies with uv..."
ssh ${PA_USER}@${PA_HOST} << EOF
    cd ~/${PROJECT_DIR}
    source .venv/bin/activate
    uv pip sync requirements/production.txt
EOF
echo "   âœ… Dependencies installed"

# Step 3: Run migrations
echo "ðŸ—„ï¸  Step 3/6: Running database migrations..."
ssh ${PA_USER}@${PA_HOST} << EOF
    cd ~/${PROJECT_DIR}
    source .venv/bin/activate
    python manage.py migrate --noinput
EOF
echo "   âœ… Migrations complete"

# Step 4: Collect static files
echo "ðŸ“¦ Step 4/6: Collecting static files..."
ssh ${PA_USER}@${PA_HOST} << EOF
    cd ~/${PROJECT_DIR}
    source .venv/bin/activate
    python manage.py collectstatic --noinput --clear
EOF
echo "   âœ… Static files collected"

# Step 5: Reload web app
echo "ðŸ”„ Step 5/6: Reloading web app..."
curl -X POST \
    -H "Authorization: Token ${PYTHONANYWHERE_API_TOKEN}" \
    https://www.pythonanywhere.com/api/v0/user/${PA_USER}/webapps/${PA_USER}.pythonanywhere.com/reload/
echo "   âœ… Web app reloaded"

# Step 6: Verify deployment
echo "âœ… Step 6/6: Verifying deployment..."
sleep 10
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${PA_USER}.pythonanywhere.com/)
if [ "$HTTP_CODE" -eq 200 ]; then
    echo "   âœ… Deployment successful! (HTTP $HTTP_CODE)"
else
    echo "   âŒ Deployment verification failed (HTTP $HTTP_CODE)"
    exit 1
fi

echo ""
echo "ðŸŽ‰ Deployment complete!"
echo "ðŸŒ Visit: https://${PA_USER}.pythonanywhere.com"
```

**Usage**:
```bash
# Set environment variables
export PYTHONANYWHERE_USERNAME=your-username
export PYTHONANYWHERE_API_TOKEN=your-token

# Run deployment
bash scripts/deploy.sh
```

---

## Static File Serving

### WhiteNoise Configuration

**`todo_project/settings/production.py`**:

```python
# WhiteNoise for static file serving
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',  # After SecurityMiddleware
    # ... other middleware
]

# Static files
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

# WhiteNoise configuration
WHITENOISE_AUTOREFRESH = False  # Production
WHITENOISE_USE_FINDERS = False  # Production
WHITENOISE_MANIFEST_STRICT = True
WHITENOISE_ALLOW_ALL_ORIGINS = False
```

**Benefits**:
- âœ… Serves static files directly from Django (no separate server needed)
- âœ… Compresses files (gzip/brotli)
- âœ… Cache busting with hashed filenames
- âœ… Fast (CDN-like performance)

### Collectstatic Workflow

```bash
# Collect static files (part of deployment)
python manage.py collectstatic --noinput --clear

# What it does:
# 1. Clears existing files in staticfiles/
# 2. Copies files from apps' static/ directories
# 3. Copies files from STATICFILES_DIRS
# 4. Applies compression and hashing (WhiteNoise)
```

---

## Database Migration Strategy

### Migration Workflow

```mermaid
graph LR
    A[Local Development] -->|makemigrations| B[Create Migration]
    B -->|Commit to Git| C[GitHub]
    C -->|Deploy| D[PythonAnywhere]
    D -->|migrate| E[Apply to Production DB]

    style B fill:#fff9c4
    style E fill:#c8e6c9
```

### Zero-Downtime Migrations

**Best Practices**:

1. **Backward-compatible migrations first**:
   ```python
   # Good: Add column as nullable first
   class Migration(migrations.Migration):
       operations = [
           migrations.AddField(
               model_name='task',
               name='archived',
               field=models.BooleanField(null=True),  # Nullable first
           ),
       ]
   ```

2. **Deploy code**

3. **Populate data** (if needed):
   ```python
   # Data migration
   def populate_archived(apps, schema_editor):
       Task = apps.get_model('tasks', 'Task')
       Task.objects.filter(archived__isnull=True).update(archived=False)
   ```

4. **Remove null constraint** (separate migration):
   ```python
   # Follow-up migration
   class Migration(migrations.Migration):
       operations = [
           migrations.AlterField(
               model_name='task',
               name='archived',
               field=models.BooleanField(default=False),  # Not nullable
           ),
       ]
   ```

### Rollback Strategy

```bash
# Rollback last migration
python manage.py migrate tasks 0001_previous_migration

# Rollback all migrations for an app
python manage.py migrate tasks zero

# View migration status
python manage.py showmigrations
```

---

## Monitoring and Logging

### Sentry Integration

**Production Settings**:

```python
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration

if not DEBUG:
    sentry_sdk.init(
        dsn=os.environ.get('SENTRY_DSN'),
        integrations=[DjangoIntegration()],
        traces_sample_rate=0.1,  # 10% of transactions
        send_default_pii=False,  # Don't send PII
        environment='production',
        release=os.environ.get('GIT_COMMIT_SHA', 'unknown'),
    )
```

**What Sentry Captures**:
- âœ… Unhandled exceptions
- âœ… 500 errors
- âœ… Slow database queries
- âœ… Performance metrics
- âœ… User context (non-PII)

### Application Logging

**Logging Configuration** (`settings/production.py`):

```python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/home/yourusername/django-todo-app/logs/django.log',
            'maxBytes': 1024 * 1024 * 10,  # 10 MB
            'backupCount': 5,
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': False,
        },
        'apps': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

**Log Rotation**:
- Automatic rotation at 10 MB
- Keep 5 backup files
- Total log storage: ~50 MB

---

## Scheduled Tasks

### PythonAnywhere Scheduled Tasks

**Example: Database backup**:

```bash
# Run daily at 2 AM
# Task: /home/yourusername/django-todo-app/.venv/bin/python /home/yourusername/django-todo-app/scripts/backup_db.py
```

**`scripts/backup_db.py`**:

```python
#!/usr/bin/env python
import os
import subprocess
from datetime import datetime

BACKUP_DIR = '/home/yourusername/backups'
DB_NAME = 'yourusername$todo_db'
DB_HOST = 'yourusername.postgres.pythonanywhere-services.com'
DB_USER = 'yourusername'

# Create backup filename
timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
backup_file = f'{BACKUP_DIR}/todo_db_{timestamp}.sql'

# Run pg_dump
subprocess.run([
    'pg_dump',
    '-h', DB_HOST,
    '-U', DB_USER,
    '-d', DB_NAME,
    '-f', backup_file
], check=True)

print(f'âœ… Backup created: {backup_file}')

# Keep only last 7 backups
backups = sorted(os.listdir(BACKUP_DIR))
if len(backups) > 7:
    for old_backup in backups[:-7]:
        os.remove(os.path.join(BACKUP_DIR, old_backup))
        print(f'ðŸ—‘ï¸  Removed old backup: {old_backup}')
```

---

## Health Checks and Uptime Monitoring

### Health Check Endpoint

**`apps/tasks/views.py`**:

```python
from django.http import JsonResponse
from django.db import connection

def health_check(request):
    """Simple health check endpoint."""
    try:
        # Check database connection
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")

        return JsonResponse({
            'status': 'healthy',
            'database': 'connected',
        })
    except Exception as e:
        return JsonResponse({
            'status': 'unhealthy',
            'error': str(e),
        }, status=500)
```

**URL**: `/health/`

### External Uptime Monitoring

**Options**:
- UptimeRobot (free): Ping `/health/` every 5 minutes
- Pingdom
- StatusCake

**Alert if**:
- HTTP status != 200
- Response time > 5 seconds
- 3 consecutive failures

---

## Rollback Procedure

### Emergency Rollback

```bash
# 1. SSH to PythonAnywhere
ssh yourusername@ssh.pythonanywhere.com

# 2. Navigate to project
cd ~/django-todo-app

# 3. Checkout previous commit
git log --oneline -5  # Find previous commit
git checkout <previous-commit-sha>

# 4. Reload web app
# Via API:
curl -X POST \
    -H "Authorization: Token $PYTHONANYWHERE_API_TOKEN" \
    https://www.pythonanywhere.com/api/v0/user/yourusername/webapps/yourusername.pythonanywhere.com/reload/

# 5. If migrations are the issue, rollback migrations
python manage.py migrate tasks 0001_previous_migration

# 6. Return to main branch when issue is fixed
git checkout main
```

---

## Performance Optimization

### PythonAnywhere-Specific Optimizations

1. **Database connection pooling** (via pgbouncer):
   ```bash
   # Contact PythonAnywhere support to enable
   ```

2. **Static file caching**:
   - WhiteNoise sets far-future cache headers
   - Browsers cache static files for 1 year

3. **Database query optimization**:
   - Use `select_related()` and `prefetch_related()`
   - Enable Django query logging in development

4. **Compression**:
   - WhiteNoise compresses static files (gzip/brotli)
   - Django GZipMiddleware for dynamic content

---

## Scaling Considerations

### Current Capacity (Single Web Worker)

- **Concurrent users**: ~100-200
- **Requests/minute**: ~1,000
- **Database connections**: ~20

### Scaling Path (Post-MVP)

1. **Vertical scaling**: Upgrade PythonAnywhere plan
2. **Horizontal scaling**: Multiple web workers
3. **Database scaling**: Dedicated PostgreSQL server
4. **Caching layer**: Redis for sessions/cache
5. **CDN**: CloudFront for static files

### When to Scale

**Monitor these metrics**:
- Response time > 500ms (p95)
- Error rate > 1%
- CPU usage > 80% (sustained)
- Database connections > 80% of pool
